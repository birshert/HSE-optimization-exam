Чтобы понимать билет, вначале обратитесь к вопросам 1.12 и 1.13

 \subsubsection{Примеры сведения задачи линейного программирования к канонической форме}

 Смотреть пункт 1.12

 \subsubsection{Симплекс-метод для решения задачи линейного программирования (в версии revised simplex method)}

 \textbf{Определение:} $x$ - угловая точка множества $F$, если $\not\exists y, z \in F, y,z \neq x, \alpha \in (0, 1) : x = \alpha y + (1 - \alpha) z$


 \textbf{Утверждение:} $x$ - угловая точка множества $\{ x | Ax = b, x \ge 0 \}  \Leftrightarrow \exists B, N : \{1, 2, ..., n\} = B \cup N , |B| = p, |N| = n - p, x_N = 0, A_B = [A_{.,i}]_{i\in B} \in \mathbb{R}^{p x p} $ - невырожденная


 \textit{Ремарка - $B$ от слова базис}


 $Ax= b = A_B x_B + A_N x_N, x_B \in \mathbb{R}^{p} , x_N \in \mathbb{R}^{n - p}$, знаем, что $x_N = 0 \Rightarrow x_B = A_b^{-1} * b \ge 0$

 \textit{На лекции было сказано что факт доказывается тривиально}
 \qed

 Перестановка одной координаты в множествах $B$ и $N$ соответствует переходу к соседней угловой точке.


 Запишем вновь нашу задачу линейного программирования и условия ККТ чтобы пояснить как находить угловую точку.

 Задача условной оптимизации:
\[
    \begin{cases}
         c^Tx \to \underset{x}{min}, x \in \mathbb{R}^n\\
         Ax = b,\\
         x \ge 0\\
    \end{cases}
\]

Функция Лагранжа:
\[
    L(x, \lambda, \mu) = c^T x - \lambda^T x + \mu^T(Ax - b)
\]

Запишем условия ККТ:
\[
    \begin{cases}
         \nabla_x L(x, \lambda, \mu) = c - \lambda + A^T \mu = 0,\\
         Ax = b,\\
         \lambda \ge 0\\
         \lambda_i x_i = 0, \: i=1,\dots, n
    \end{cases}
\]


$x$ - угловая точка, $x_N = 0, x_B = A_b^{-1}b \ge 0$ - то есть есть такое разбиение. Давайсте восстановим значения $\lambda $ и $\mu$ чтобы ККТ были выполнены.

$\lambda_B = 0$ - тогда произведение для всех индексов в ККТ будет равно нулю. Запишем следующее: $A^T\mu + c = \lambda$.  Рассмотрим в этом уравнение подмножество, соответствующее $B$: $A_B^T \mu + c_B = \lambda_b = 0 \Rightarrow \mu = -A_b^{-T} c_B$ Таким образом мы восстановили $\mu$.  С этим знанием мы можем найти $\lambda_N$: $A_N^T \mu + c_N = \lambda_N \Rightarrow \lambda_N = c_N - A_N^T A_B^{-T} c_B = c_N - (A_B^{-1} A_N)^T c_B$. Таким образом мы удовлетворили всем условия ККТ, кроме третьего условия, с которым еще надо повозиться.

Если уже $\lambda_N \ge 0 \Rightarrow x - $ решение.

Если это не выполнено, то ситуация следующая:
$\exists q \in N : \lambda_q < 0$ и надо идти в другую угловую точку.

Теперь неформально можно описать шаг симплекс-метода : увеличиваем $x_q$ до тех пор, пока какой-то из $(x_B)_i$ не станет равен нулю. Это и будет означать переходу в соседнюю угловую точку.

 Распишем в виде формул.

 Изначально есть $x: Ax = b, x_N = 0$. Вместо этой точки строим точку $x^+ : x_i^+ = 0, i\in N\backslash \{q\}$. Тогда получается следующее: $$
 Ax^+ = b = A_B x_B^+ + A_q x_q^+ = A_B x_B
 $$

Поделим это выражение на невырожденную $A^{-1}$:
$$
x_B^+ = x_B - A_B^{-1} A_q x_q^+
$$

$A_B^{-1} A_q$ это какой-то вектор $d$ размера $p$. $x_q^+$ это число. Тогда получается:
$$
x_B^+ = x_B - d x_q^+ \ge 0
$$

Если все компоненты вектора $d$ меньше либо равны $0$ то решений не будет. Если же найдутся $\exists j : d_j > 0$, то переход в ноль какой-то компоненте будет соответствовать следующему:

$$
(x_B)_j - d_j x_q^+ = 0 \Rightarrow x_q^+ = \frac{(x_B)_j}{d_j}
$$

Если же таких $j$ несколько, то $x_q^+ = \underset{j:d_j > 0}{min} \frac{(x_B)_j}{d_j}$
 Осталось только перекинуть один индекс из множества $B$ в $N$:

 $$
 B = B \cup \{q\} \backslash \{j\} \\
 N = N \backslash \{q\} \cup \{j\}
 $$

 Вот так выглядит шаг симплекс-метода. Давайте докажем, что действительно на каждом шаге есть прогресс.

 \textbf{Утверждение:} На каждом шаге симплекс-метода целевая функция уменьшается

 \noindent

 \textit{Доказательство:}
 $$ c^T x^+ = c_B^T X_B^+ + c_q x_q^+ = c_B^T (x_B - d x_q^+) + c_q x_q^+ = c_B^T x_B + x_q^+(c_q - c_B^T d)$$

 Рассмотрим $c_B^T d$. Это выражение равно $c_b^T A_B^{-1} A_q$, а ранее мы установили, что это равно $- \mu^T A_q = - (\lambda_q - c_q)$

 Подставим этот результат в предыдущее выражение:

 $$
 c_B^T x_B + x_q^+(c_q - c_B^T d) = c^T x + x_q^+(c_q + \lambda_q - c_q) = c^T x + \lambda_q x_q^+
 $$

 Если мы посмотри на знак последнего слагаемого, то он будет отрицательный, так как уже известно, что $\lambda_q < 0$, мы ее такой выбрали, а $x_q^+$ в свою очередь строго больше нуля (так как мы в ту сторону двигаем)

 Значит $c^T x + \lambda_q x_q^+ < c^T x$

 Таким образом значение целевой функции уменьшается на каждом шаге метода. \qed

 Теперь формально опишем один шаг симплекс-метода.

\textbf{Шаг симплекс-метода:}
\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Procedure{Revised simplex method step}{$x: x_N = 0, x_B = A_b^{-1} b \ge 0$}
        \State Решить СЛАУ $A_B^T \mu = - c_B$
        \State $\lambda_N \gets c_N + A_N^T \mu$
        \State Если $\lambda_N \ge 0,$ то СТОП (найдено оптимальное решение)
        \State Выбрать $q\in N, \lambda_q < 0$
        \State Решить СЛАУ $A_B d = A_q$
        \State Если $d \le 0,$ то СТОП (решения не существует)
        \State $x_q^+ \gets \underset{i : d_i > 0}{min} \frac{(x_B)_i}{d_i}$
        \State $j \gets \underset{i : d_i > 0}{argmin} \frac{(x_B)_i}{d_i}$
        \State $x_B^+ \gets x_b - d x_q^+$
        \State $x_N^+ \gets (0, 0, \dots, x_q^+, 0, \dots, 0)$
        \State $B \gets B \cup \{q\} \backslash \{j\}$
        \State $N \gets N \backslash \{q\} \cup \{j\}$
        \State \Return $x$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

Прокомментируем еще раз алгоритм. Сначала по заданной точке мы находим $\mu$ и $\lambda$. Собственно изначально мы решаем СЛАУ относительно $\mu$, и с помощью $\mu$ находим $\lambda$. Если все $\lambda$ неотрицательные, то мы удовлетворили условиям ККТ и у нас есть решение, поэтому мы останавливаемся. Если же условие не выполнено, то мы выбираем какую-то компоненту $\lambda_q$ меньше нуля и дальше начинаем двигать точку $x_q$ на вектор $d$. Вектор $d$ мы находим через решение СЛАУ. Если все компоненты этого вектора неположительные, то это означает что целевую функцию можно увести в минус бесконечность, тогда решений не существует. Если же хотя бы один $d$ положительный, то тогда мы совершаем сдвиг согласно написанным формулам.
И в конце перекидываем индексы между $B$ и $N$.

По итогу что мы имеем метод, который сходится за конечное число шагов (благодаря доказанному выше утверждению про уменьшение целевой функции на каждом шаге). Однако, справедлива будет для общего случая следующая оценка на число шагов - $C_n^p$(число сочетаний) по построению метода. На практике эта сложность практически неактуальна (даже теоретический пример для такой сложности предъявили не сразу после создания метода), часто метод находит оптимальную точку за линейное время от $p$.

Стоит обсудить еще следующую особенность симплекс-метода. Как видно по алгоритму, здесь нет какого-то понятия вроде эпсилон-точности, как в предыдущих рассмотренных методах. Либо мы в итоге приходим в оптимум, либо нет. Это связано с особенностью хождения по угловым точкам. В какой-то момент мы можем пройти очень маленькое расстояние, так как две угловые точки находятся очень близко друг к другу, но это не значит, что оптимум близко, хотя изменение целевой функции будет минимальным. Из-за этой причины нет смысла в каком-то заранее задаваемом параметре точности.

Информацию далее для сдачи экзамена учить не надо, но если вы будете это знать, то это будет полезно (информация с консультации)

\textbf{Возникающие проблемы при использовании.}
\begin{itemize}

    \item На каждом шаге у матрицы $A_B$ меняется только один столбец, поэтому в некоторых реализациях хранится только $LU$ разложение, в котором изменения происходят с помощью специальных алгоритмов.

    \item Момент связанный с выбором компоненты $q$. Изначально была стратегия $q^* = \underset{q}{argmin} \lambda_q $. Данная стратегия обоснована анализом уменьшения функции на итерации метода. На практике в этом месте это было бы слишком дорого, поэтому в этом моменте возникают различные эвристики которые хорошо выбирают  $q$.

    \item Момент связанный с вырожденными точками. Угловая точка называется вырожденной, если какая-то или несколько из компонент из $B$ равны нулю. В таком случае $x_q^+$ двигать за пределы множества нельзя, и эта компонента будет равна $0$. Тогда изменение целевой функции не уменьшится, метод может даже зациклиться между несколькими вырожденными точками. В таком случае надо вставить какой-то АНТИЦИКЛИН (что-то вроде добавления нормального шума к вектору $b$ из $Ax = b$.

    \item Момент связанный с выбором начальной угловой точки. Не всегда очевидно как выбрать начальную точку, один из возможных способов решения это так называемый метод "первый фазы". Он заключается в формировании какой-то специальной задачи, про которую известно что ее решение будет содержать какую-то угловую точку нашего изначального множества ($Ax = b$), и для этой задачи мы без проблем умеем выбирать начальную угловую точку. То есть первую фазу мы решаем с помощью симплекс-метода, получаем начальную точку и решаем уже с этой начальной точкой нашу задачу, так называемая вторая фаза.

\end{itemize}